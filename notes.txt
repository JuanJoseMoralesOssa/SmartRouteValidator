El repositorio implementa una mezcla entre arquitectura limpia y atomic design

Una cosa muy interesante que logre visualizar con la arquitectura
 limpia fue que antes en el dise単o del diagrama de clases de analisis,
 aparecio un controlador que lo llame RouteManagementController, el cual
 es el encargado de crear las cuidades de las rutas si las cuidades no existen,
 encargado de manejar la relacion de muchos a dos entre las rutas y las cuidades,
 despues de basarme en las clases de arquitectura limpia y de ver su aplicacion con
 un ejempo de loopback me di cuenta que esa relacion ya la crea loopback por defecto,
 al igual que crea un controlador especifico para el manejo de estas dos entidades.

El repositorio implementa buenas practicas como que devuelve una copia de el diccionario


Implemente un repositorio que maneja como almacenamiento un diccionario, debido a que
 el proyecto era principamente un crud que realizaba sus operaciones por medio de IDs,
 por tanto un diccionario es una buena opcion para manejar las entidades,
 ya que permite un acceso rapido a los datos, y ademas permite manejar las entidades,
 sin necesidad de recorrer una lista o un array, lo que mejora el rendimiento. Aunque
 aveces si necesito recorrer el diccionario para buscar una entidad por un atributo;
 el objetivo del proyecto no es hacer un sistema de busqueda avanzado y como lo dice el problema,
 se centraba en el manejo de las rutas principalmente cuando se crean y actualizan y el diccionario
 me da una mayor velocidad cuando quiero actualizar una entidad.

 El sistema no lo pense para manejar una gran cantidad de datos, por lo que
 no implemente una paginacion de los datos, ya que el objetivo del proyecto no es
 manejar una gran cantidad de datos, sino que se centra en el manejo de las rutas. Por tanto,
 de ser un array no tendria una ventaja significativa ya que al ser pocos datos no me demoro en
 recorrerlos.

 En los mocks se aplico el principio de abstraccion, para darle una mayor legibilidad al codigo y una mejor comprension

 Se modifico el codigo original del trigger porque habia redundancia en los arreglos y solo con un arreglo de visitados era
 sufiente para resolver el problema, ademas que se guardaba toda la entidad lo que consumia mas memoria, ahora solo guarda el id,
 tambien se utilizo un diccionario y no un arreglo para mejorar el tiempo de respuesta O(n) con n variable a la longitud de elementos y
 se cambio por un O(1) que es un tiempo constante.


Validar:
  Se ha tratado de seguir las buenas practicas de arquitectura limpia, y de atomic design,
  separando las responsabilidades de los controladores, servicios y repositorios.
  He tratado de manejar un alto nivel de abstraccion en los metodos, un alto nivel
  de cohesion y bajo acoplamiento, un buen manejo de excepciones y errores, un buen manejo del
  single responsability principle. Ademas de otras recomendaciones como que los constructores, los getters y setters no
  tengan logica de negocio, que los metodos no tengan mas de 10 lineas de codigo, que los nombres
  de las variables y metodos sean descriptivos, que los metodos no tengan mas de 3 parametros,
  que los metodos sean pequenos y hagan una sola cosa, que los metodos sean facilmente
  testables y mantenibles. Evitar el codigo repetido, redundante o codigo muerto.
  He tratado de seguir el principio KISS, y que el codigo sea lo mas simple posible.
  Trate de que los controladores siguieran un servicio descentralizado, donde los controladores
  no tengan logica de negocio, y que solo se encarguen de recibir los datos,
  llamar a los servicios y responder con los mensajes de exito o error.
  Trate de que los servicios manejen la logica de negocio, como validar existencias
  o verificar que los datos sean correctos, y a su vez sean descentralizados,
  donde cada servicio maneje una sola entidad.

Contras:
  Antes pensaba que seguir toda esta infraestructura sobredise単ar la solucion ya que
  para solo dos entidades me parecia que estaba sobre pensando la solucion. Sin embargo,
  me di cuenta por esa misma razon era una buena opcion porque sino tendria codigo repetido
  y redundante en cada controlador, si seguia el dise単o tradicional orientado a POO, el controlador
  tendria que manejar sus listas o diccionarios de datos internamente y llegue a pensar en su momento,
  hasta tener un god object de controlador que maneje todo, lo cual es una mala practica. Despues
  pase a tener dos controladores para cada entidad como dicen los buenos principios pero aun no tenia los servicios,
  por tanto habia un alto acoplamiento de controladores y rompia el single responsability, mejor era separ logica en
  los servicios, y que a su vez los servicios sean descentralizados.
  De hecho, pense en su momento de crear aun mas abstracciones y clases para el manejo de las relaciones,
  pero en este punto si sentia que era un sobre dise単o de la solucion ya que aunque tendria dos agregaciones,
  una de que cada ruta tendria una ciudad de origen y una ciudad de destino, sigue siendo una relacion de
  1 a 1, y aunque esta repetida no le vi mucha aplicacion ya que era una relacion que salia mas facil
  manejarla directamente en el controlador. La otra relacion de que una ciudad puede tener muchas rutas,
  tan poco vi la necesidad de implementar esta relacion en los repositorios, ya que de implementar alguna
  tiraria mas por la de las rutas a las ciudades ya que las rutas es el core de la aplicacion y serian
  las que tendrian mas consultas lo que demuestra una mayor necesidad de acceder a la informacion,
  junto con una mayor cantidad de datos.

  Por tanto, para disminuir la carga de responsabilidades de las clases controladoras,
  cree los servicios y los repositorios, para que ellos manejen las colecciones, el guardar, el
  actualizar, el eliminar, el buscar de las entidades. Y que los controladores, solo reciba los datos,
  llame a los servicios y responda con los mensajes de exito o error. Que los servicios sean los
  encargados de tener la logica de negocio, como validar existencias o verificar que los datos
  sean correctos, y que los repositorios manejen las colecciones de datos, ya sea un array o un diccionario.



Posibilidades de mejora:
  Crear un datasource que maneje los repositorios independientemente
  si es un array o un diccionario.

  Implementar singleton en el store global para los repositorios y los controladores, y en un futuro
  el datasource. Ya que son dependencias que no cambian a lo largo de la ejecucion
  de la aplicacion, y que no necesitan ser instanciadas varias veces.

  Implementar en un futuro la agregacion de uno a uno entre rutas y ciudades.

  Mejorar la forma de enviar los mensajes de error y exito, para que sean mas descriptivos
  o crea una clase de respuesta que maneje los mensajes de error y exito,

  Implementar la paginacion de los datos, ya que si bien el repositorio
  devuelve una copia del diccionario, no implementa la paginacion de los datos,
  por lo que si se tiene un gran volumen de datos, se tendria que implementar
  una paginacion para no cargar todos los datos de una sola vez.

  Implementar en la vista detalla de una ciudad que ademas de las rutas que se muestran,
  se muestren los caminos que tienen varias rutas con origen o con destino que
  tenga esa ciudad

  Que diga si es un hueco o si es una fuente

  Implementar un algoritmo que calcule las escalas entre todas las ciudades

  Implementar que se le pueda cambiar el color a la ruta y que muestre el constructores

  Implementar el autocomplete con
    searchKeys={['name', 'country']}
     minCharsToSearch={2}

Estas dos son mejoras que van mas por la parte de lo que esta bien tener, yo me enfoque en que
el proyecto este lo suficientemente bueno, y cumpla con los requisitos funcionales del problema,
estas mejoras no afectan directamente a los requisitos funcionales y por tanto no vi una necesidad de
implementarlas en este momento, pero si son mejoras que se pueden implementar en un futuro.
  Implementar un datasource que se conecte con index DB para que cuando
  refresque la pagina, se mantengan los datos en el navegador,
  y no se pierdan al recargar la pagina.

  Realizar una prueba de carga para ver el rendimiento, y como se comporta
  la aplicacion con un gran volumen de datos, y si es necesario implementar
  mejoras en la arquitectura o en la forma de manejar los datos.

  Esto me mostro que aveces lo suficientemente bueno es suficiente para un proyecto,
  y que no siempre es necesario implementar todas las mejoras posibles, pero si es importante
  tener en cuenta que siempre se pueden realizar mejoras en el futuro. Pero si no se afecta en
  un grado significativo a los requisitos funcionales, no es necesario implementarlas.
